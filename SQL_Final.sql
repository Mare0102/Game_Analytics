-- ACTIVATED, REENGAGEMENT, CHURN - WEEKLY

CREATE OR REPLACE VIEW arc_week_1  AS
SELECT user_id, WEEK(ts) AS WEEK,
	LEAST(LEAD(WEEK(ts)) OVER w, WEEK(ts) + 1) AS 'ACTIVE EXPIRY',
    CASE WHEN LAG(WEEK(ts)) OVER w IS NULL THEN TRUE ELSE FALSE END AS 'ACTIVATED',
    CASE WHEN LEAD(WEEK(ts)) OVER w IS NULL THEN TRUE
		WHEN LEAD(WEEK(ts)) OVER w - WEEK(ts) > 1 THEN TRUE
        ELSE FALSE
        END AS 'CHURNED',
	CASE WHEN LAG(WEEK(ts)) OVER w IS NULL THEN FALSE
		WHEN WEEK(ts) - LAG(WEEK(ts)) OVER w <= 1 THEN FALSE
		WHEN row_number() OVER w > 1 THEN TRUE
        ELSE FALSE
        END AS 'REENGAGED'
FROM entry_events
WINDOw w AS (PARTITION BY user_id ORDER BY WEEK(ts));

CREATE OR REPLACE VIEW arc_week_2 AS
SELECT 
	SUM(CAST(ACTIVATED AS SIGNED)) ACTIVATED,
    SUM(CAST(CHURNED AS SIGNED)) CHURNED,
    SUM(CAST(REENGAGED AS SIGNED)) REENGAGED,
    WEEK
FROM arc_week_1
GROUP BY WEEK;

select * from arc_week_2;


-- ACTIVATED, REENGAGEMENT, CHURN - DAILY

CREATE OR REPLACE VIEW arc_day_1 AS
SELECT user_id, DATE(ts) AS DATE,
	LEAST(LEAD(DATE(ts)) OVER w, DATE(ts) + 30) AS 'ACTIVE EXPIRY',
    CASE WHEN LAG(DATE(ts)) OVER w IS NULL THEN TRUE ELSE FALSE END AS 'ACTIVATED',
    CASE WHEN LEAD(DATE(ts)) OVER w IS NULL THEN TRUE
		WHEN LEAD(DATE(ts)) OVER w - DATE(ts) > 30 THEN TRUE
        ELSE FALSE
        END AS 'CHURNED',
	CASE WHEN LAG(DATE(ts)) OVER w IS NULL THEN FALSE
		WHEN DATE(ts) - LAG(DATE(ts)) OVER w <= 30 THEN FALSE
		WHEN row_number() OVER w > 1 THEN TRUE
        ELSE FALSE
        END AS 'REENGAGED'
FROM entry_events
WINDOw w AS (PARTITION BY user_id ORDER BY DATE(ts));

CREATE OR REPLACE VIEW arc_day_2 AS
SELECT 
	SUM(CAST(ACTIVATED AS SIGNED)) ACTIVATED,
    SUM(CAST(CHURNED AS SIGNED)) CHURNED,
    SUM(CAST(REENGAGED AS SIGNED)) REENGAGED,
    DATE
FROM arc_day_1
GROUP BY DATE;

SELECT * FROM arc_day_2;


-- RETENTION DAY 1, DAY 7, DAY 28

CREATE OR REPLACE VIEW retention_1 AS
SELECT a.user_id, DATE(a.ts) DATE, DATE(b.ts) DATE_2
FROM entry_events a
LEFT JOIN entry_events b 
ON a.user_id = b.user_id;

CREATE OR REPLACE VIEW retention_2 AS
SELECT * FROM retention_1
WHERE DATE_2>DATE;

CREATE OR REPLACE VIEW retention_3 AS
SELECT 
	DATE,
    COUNT(DISTINCT user_id) USER,
    COUNT(DISTINCT CASE WHEN DATEDIFF(DATE_2, DATE) = 1 THEN
		user_id ELSE NULL END) DAY_1,
	COUNT(DISTINCT CASE WHEN DATEDIFF(DATE_2, DATE) = 7 THEN
		user_id ELSE NULL END) DAY_7,
	COUNT(DISTINCT CASE WHEN DATEDIFF(DATE_2, DATE) = 28 THEN
		user_id ELSE NULL END) DAY_28
FROM retention_2
GROUP BY DATE ORDER BY DATE;

CREATE OR REPLACE VIEW retention_4 AS
SELECT DATE, USER,
CONCAT(ROUND((DAY_1/USER)*100,2),'%') DAY_1,
CONCAT(ROUND((DAY_7/USER)*100,2),'%') DAY_7,
CONCAT(ROUND((DAY_28/USER)*100,2),'%') DAY_28
FROM retention_3;

SELECT * FROM retention_4;


-- DAILY ACTIVE USER (DAU), MONTHLY ACTIVE USER (MAU), STICKINESS RATIO (DAU/MAU)

CREATE OR REPLACE VIEW daumau_1 AS
SELECT DATE, DAU, MAU, ROUND(CAST(DAU AS SIGNED) / (CASE WHEN MAU = 0 THEN NULL ELSE MAU END) * 100,2)  as Stickiness_pct
FROM (
	SELECT DATE(ts) DATE,
		COUNT(*) OVER (PARTITION BY DATE(ts) ORDER BY DATE(ts)) AS DAU,
		COUNT(*) OVER (PARTITION BY MONTH(ts) ORDER BY MONTH(ts)) AS MAU
	FROM (SELECT DISTINCT user_id, DATE(ts) ts FROM entry_events) t
	ORDER BY DATE) t
ORDER BY DATE;

SELECT DISTINCT * FROM daumau_1;

